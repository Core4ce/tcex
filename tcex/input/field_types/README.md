# Input Types

## Intent

Input Types are intended to provide a layer of validation that ensures that a ThreatConnect Integration's defined inputs
receive values that are of the expected type. If a particular input of an Integration receives a value that is not of
the input's configured type, a `ValueError` is raised. It is important to note that, while Input Types, provide a layer
of type enforcement, this enforcement is triggered only upon Integration initialization. If Input Types are manually
instantiated, there is no general guarantee that the Input Type's validation will trigger. Similarly, if an Input Type
that is generated by the TCEX framework upon Integration load is then mutated within Integration code, there is no
general guarantee that the mutation will be validated. Therefore, Input Types should only be used when defining the inputs
of an Integration. Upon Integration load, the TCEX framework will look at the Integration's input definitions and will
instantiate the defined Input Types with the values passed to the Integration. It is at this time that each Input Type's
validation will be triggered. If no `ValueError` is raised, then the instances of the Input Types listed in the Integration's
input definition will be passed to the main Integration logic in order to be used; however, as a rule of thumb, these
instances should be treated as immutable values in order to maintain type integrity.

## Usage

This section provides a basic example that illustrates how Input Types can be used to define inputs for an Integration.

Consider a fictitious Playbook Integration with a single Action named "My Action". This Action takes a single input,
which is named "My Input". "My Input" accepts String and StringArray values.

Integration inputs are defined as Models, which are classes that inherit from `pydantic.BaseModel`. These model classes
should have one property for each input that should be defined.

The input definition for our sample Action would be defined as follows:

```
    class MyAction(BaseModel):
        """Model that defines inputs for Action 'My Action'"""

        # Define the expected type of input "My Input".
        # Note that, even though this input takes both String and an Array of Strings, only StringArray is needed.
        # Single String values will be automatically converted to an Array of one String.
        my_input: StringArray
```

The above example shows that the "My Input" input accepts both a String and an Array of Strings. As the type of `my_input`
is simply defined to be StringArray, then `my_input` is configured with the default StringArray behavior. For details
on default Array behavior and how to customize it, see the `Customizable Arrays` documentation section.


By default, the above definition would accept neither an empty String nor an empty Array as an initialization value. Input
types come with `Optional` variants, which allow empty values. `Optional` variants have class names equal to their
non-optional counterparts, but with "Optional" appended to the name. For example, the `Optional` variant of StringArray
would be StringArrayOptional.

The following definition would now accept both empty Strings and an empty Arrays as initialization values:

```
    class MyAction(BaseModel):
        """Model that defines inputs for Action 'My Action'"""

        # Can now be initialized with empty values
        my_input: StringArrayOptional
```

Neither of the two examples above can be initialized with a `None` value. The `Optional` type hint must be used if
initializing an input with `None` is desired:

The following definition allows either `None` or non-empty values as valid initialization values for `my_input`:
```
    from typing import Optional

    class MyAction(BaseModel):
        """Model that defines inputs for Action 'My Action'"""

        # This input can now be initialized with a None value, but not with any empty values
        my_input: Optional[StringArray]
```

The following definition allows either `None` and empty values as valid initialization values for `my_input`:
```
    from typing import Optional

    class MyAction(BaseModel):
        """Model that defines inputs for Action 'My Action'"""

        # This input can now be initialized with a None value and also with values considered empty
        my_input: Optional[StringArrayOptional]
```

When Array Types are initialized using an Array value, no check is performed on the members of the Array to see if
any of them are empty/null. This means that it is acceptable to initialize a StringArray with the following: `['', None]`
(note that each Array type may have its own definition of what empty/null values are).

If the above behavior is not desired, it is possible to customize the default Array behavior using a custom Array factory
function as follows:

```
    from tcex.input.customizable import custom_string_array

    class MyAction(BaseModel):
        """Model that defines inputs for Action 'My Action'"""

        # This input can no longer be initialized with a list that contains empty/null values.
        my_input: custom_string_array(
            allow_empty_members=False,
            allow_null_members=False
        )
```

All built-in Array types have a corresponding custom Array factory function. See the `Customizable Arrays` documentation
section for more details.


## Array Types

### Abstract Array Classes

#### AbstractArray

Abstract Array class that all Array input types inherit from. This class provides high-level utility methods for
working with Arrays and Array Members, which are publicly available in all Array implementations that inherit from
this class. This class also contains internal code that is responsible for validating that application input values
truly belong in the input's configured array type when the application executes.

##### Methods

Note that some of AbstractArray's public methods rely on abstract methods, which must be implemented by a child of AbstractArray.
It is a best practice to call the methods described below from the Array type that the user currently desires to work with.
For example,if the user desires to work with Strings, the user should call the below methods from the StringArray class or from
a StringArray instance in order to produce accurate results.

As a rule of thumb, Abstract Array classes should not be referenced in code, unless the code is defining a new Array type
that inherits from an Abstract Array class.

###### assert_is_array

Parameters:

- `value`: The value upon which the `is_array` assertion should be performed.

This method passes `value` to the `is_array` method and raises a `ValueError` if `is_array` returns `False`. See

`is_array` method documentation for more details.

###### assert_is_member

Parameters:

- `value`: The value upon which the `is_array_member` assertion should be performed.

This method passes `value` to the `is_array_member` method and raises an `InvalidMemberException` if `is_array_member` returns `False`.

Note that `is_array_member` is an abstract method and must be implemented by a child of this class.

See `is_array_member` method documentation for more details.

###### assert_not_empty

Parameters:

- `value`: The value upon which the `is_empty` assertion should be performed.

This method passes `value` to the `is_empty` method and raises an `EmptyArrayException` if `is_empty` returns `True`.

Since this method relies on the `is_empty` method, calling this method can result in a `ValueError` if `value` is not
an Array.

See `is_empty` method documentation for more details.

###### assert_not_empty_member

Parameters:

- `value`: The value upon which the `is_empty_member` assertion should be performed.

This method passes `value` to the `is_empty_member` method and raises an `EmptyMemberException` if `is_empty_member` returns `True`.

Note that `value` is first passed to `assert_is_member`, which can result in an `InvalidMemberException` if `value` is not
considered a member of the Array type from which this method is called.

See `is_empty_member` method documentation for more details.

###### is_array

Parameters:

- `value`: The value that will be checked.

This method returns `True` is `value` is an Array and returns `False` otherwise. The check performed is `isinstance(value, list)`.

###### is_array_member

Parameters:

- `value`: The value that will be checked for array membership.

This method checks whether `value` is considered a member of the Array from which this method is called.

This method is an abstract method that should be implemented by a child of this class, as each Array implementation will accept
different values as members. The general contract that a child class must fulfill when implementing this method is to return
`True` if `value` is considered a member of the Array. `False` should be returned if `value` is not a member of the Array.

Attempting to call this method directly from AbstractArray will result in a `NotImplementedError`.

###### is_empty

Parameters:

- `value`: The value that will be checked for array emptiness.

This method returns `True` if `value` is an empty Array and returns `False` if `value` is a non-empty Array.
This method raises a `ValueError` if `value` is not an Array.

###### is_empty_member

Parameters:

- `value`: The value that will be checked.

This method checks if `value` is equal to what is considered the empty value of the Array from which this method is called.

This method is an abstract method that should be implemented by a child of this class, as each Array implementation will have
its own definition of what is considered an empty Array member. The general contract that a child class must fulfill when
implementing this method is to return `True` if `value` is considered a empty member of the Array. `False` should be returned
if `value` is not an empty member of the Array.

`value` should be confirmed to be a member of the array before checking if it is considered empty. This should be done
by calling the `assert_is_member` method on `value`. Therefore, an `InvalidMemberException` is expected when `value`
is not a member of the Array from which this method is called.

###### is_null_member

Parameters:

- `value`: The value that will be checked.

This method checks if `value` is null (`None`). The default implementation that this method provides simply returns
`True` if `value` is `None` and returns `False` if `value` is not `None`.

`value` should be confirmed to be a member of the array before checking if it is considered null. This should be done
by calling the `assert_is_member` method on `value`. Therefore, an `InvalidMemberException` is expected when `value`
is not a member of the Array from which this method is called.

###### pre_validation_processor

Parameters:

- `value`: The value that will be processed.

This method is a hook that is called on the input value as the Integration receives it. This method allows
for processing to be performed on `value` prior to any validation occurring. This method may even raise a `ValueError`,
and this error will be treated as a validation error.

Note if `ValueError` is not raised, this method must always return `value`, even if `value` was not mutated. The default
implementation of this method simply returns `value` as received.

#### AbstractHybridArray

AbstractHybridArray comes in handy when there is a need for a new Array type that is allowed to hold values that are
considered members of already existing Array types. For example, an Array implementation that is allowed to hold both
String and Binary types could be implemented by inheriting from this abstract class. By leveraging AbstractHybridArray
to create the aforementioned Array type, the logic within AbstractHybridArray would know to reuse the `is_array_member`,
`is_empty_member`, and `is_null_member` logic from StringArray and BinaryArray. While StringArray can only hold String types
and BinaryArray can only hold Binary types, the new String/Binary Hybrid described here would be allowed to hold both
String and Binary types.

In short, inheriting from AbstractHybridArray allows the user to combine the type-enforcement logic from existing Array
types into a new Hybrid type without needing to duplicate logic.

The only thing a user is responsible for when defining a new HybridArray is defining which existing Array types will
make up the new HybridArray. This is achieved by implementing the abstract `type_compositions` method when inheriting
from this class. Afterward, the logic within AbstractHybridArray will automatically know how to properly handle the new
hybrid type-enforcement logic. See the `type_compositions` method documentation for details.

##### Methods

###### is_array_member

Parameters:

- `value`: The value that will be checked for Array membership.

In order for a value to be considered a member of a HybridArray, it must be considered a member of at least one of the
HybridArray's type compositions. This method iterates through the different types that compose the current HybridArray
implementation being used and passes `value` to each composition's `is_array_member` method. If any of the aforementioned
calls return `True`, then `value` is considered a member of the HybridArray from which this method is being called. This
logic is already implemented within AbstractHybridArray; however, a user can always choose to extend this logic within
a child of AbstractHybridArray. If the user should choose to extend this logic, the user should ensure to call the superclass
implementation of this method in order to not lose the Hybrid functionality (`super().is_array_member(value)`).

###### is_array_member

Parameters:

- `value`: The value that will be checked for Array membership.

In order for a value to be considered a member of a HybridArray, it must be considered a member of at least one of the
HybridArray's type compositions. This method iterates through the different types that compose the current HybridArray
implementation being used and passes `value` to each composition's `is_array_member` method. If any of the aforementioned
calls return `True`, then `value` is considered a member of the HybridArray from which this method is being called.

This logic is already implemented within AbstractHybridArray; however, a user can always choose to extend this logic within
a child of AbstractHybridArray. If the user should choose to extend this logic, the user should ensure to call the superclass
implementation of this method in order to not lose the Hybrid functionality (`super().is_array_member(value)`).

###### is_empty_member

Parameters:

- `value`: The value that will be checked.

This method first passes `value` to `assert_is_member` in order to make sure that `value` is indeed considered a member
of the HybridArray before checking if it is considered an empty member of the HybridArray. This is done in case the user
has extended the `is_array_member` functionality. Afterward, this method cycles through the HybridArray's type compositions,
passing `value` into each composition's `is_empty_member` method. If any of the aforementioned calls returns `True`,
then `value` is considered to be an empty member of the HybridArray from which this method is called.

This logic is already implemented within AbstractHybridArray; however, a user can always choose to extend this logic within
a child of AbstractHybridArray. If the user should choose to extend this logic, the user should ensure to call the superclass
implementation of this method in order to not lose the Hybrid functionality (`super().is_empty_member(value)`).

###### is_null_member

Parameters:

- `value`: The value that will be checked.

This method first passes `value` to `assert_is_member` in order to make sure that `value` is indeed considered a member
of the HybridArray before checking if it is considered an empty member of the HybridArray. This is done in case the user
has extended the `is_array_member` functionality. Afterward, this method cycles through the HybridArray's type compositions,
passing `value` into each composition's `is_null_member` method. If any of the aforementioned calls returns `True`,
then `value` is considered to be a null member of the HybridArray from which this method is called.

This logic is already implemented within AbstractHybridArray; however, a user can always choose to extend this logic within
a child of AbstractHybridArray. If the user should choose to extend this logic, the user should ensure to call the superclass
implementation of this method in order to not lose the Hybrid functionality (`super().is_null_member(value)`).

###### type_compositions

Abstract method that must be implemented when defining a new HybridArray type. This method should return a list of Array types
that make up the HybridArray implementation. In other words, this method should return a list of classes that inherit from
AbstractArray.

### Built-In Array Implementations

#### String Array

An Array that is meant to hold String instances.

##### Abstract Method Implementations

###### is_array_member

Parameters:

- `value`: The value that will be checked.

This method returns `True` if `value` is a String instance or if it is `None`. Otherwise, this method returns `False`.

###### is_empty_member

Parameters:

- `value`: The value that will be checked.

This method first passes `value` to `assert_is_member`. Therefore, an `InvalidMemberException` can be raised if `value`
is not considered a member of StringArray. Afterward, this method returns `True` if `value` is equal to an empty String.
Otherwise, this method returns `False`.

#### Binary Array

An Array that is meant to hold Bytes instances.

##### Abstract Method Implementations

###### is_array_member

Parameters:

- `value`: The value that will be checked.

This method returns `True` if `value` is a Bytes instance or if it is `None`. Otherwise, this method returns `False`.

###### is_empty_member

Parameters:

- `value`: The value that will be checked.

This method first passes `value` to `assert_is_member`. Therefore, an `InvalidMemberException` can be raised if `value`
is not considered a member of BinaryArray. Afterward, this method returns `True` if `value` is equal to an empty bytes
instance (`b''`)'. Otherwise, this method returns `False`.

#### KeyValue Array

An Array that is meant to hold KeyValue instances.

##### Abstract Method Implementations

###### is_array_member

Parameters:

- `value`: The value that will be checked.

A member of KeyValueArray is a dictionary that has 'key' and 'value' keys. An optional 'variableType' key may be
included, which must be a non-empty string if present. None is also a valid member of KeyValueArray.

The 'key' key must be a non-empty string.

The 'value' key may be a String, StringArray, Binary, BinaryArray, TCEntity, TCEntityArray, and it also may be another
KeyValue or a KeyValueArray. Note that this means that the value may be a single value or a list (Array) type. If the
'value' key is a list type, then it must be a homogenous list. That is, the list may contain only Strings, only Binaries,
only TCEntities, or only KeyValues.

The 'value' key may also be None

If `value` meets the above conditions, `True` is returned. Otherwise, `False` is returned.

###### is_empty_member

Parameters:

- `value`: The value that will be checked.

An empty member of KeyValueArray is a value that passes the checks defined in `is_array_member` and is a
KeyValue that has a 'value' that is an empty list or is considered to be an empty member of StringArray or BinaryArray.

If the passed-in value is a KeyValue whose 'value' is another KeyValue or a TCEntity, the nested KeyValue/TCEntity found
in the 'value' portion of the outer KeyValue are not checked for emptiness. If the 'value' portion is a non-empty list,
the members of said list are not checked for emptiness. The passed-in KeyValue is considered non-empty in these cases.

This method raises and `InvalidMemberException` if `value` is not considered to be a member of KeyValueArray. Otherwise,
this method returns `True` if `value` meets the above conditions and returns `False` if it does not.

##### Methods Extended From Superclass

###### is_null_member

Parameters:

- `value`: The value that will be checked.

A null member of KeyValueArray is a value that passes the checks defined in `is_array_member` and is either `None` or has
a 'value' key that is `None`.

This method raises and `InvalidMemberException` if `value` is not considered to be a member of KeyValueArray. Otherwise,
this method returns `True` if `value` meets the above conditions and returns `False` if it does not.

#### TCEntity Array

An Array that is meant to hold TCEntity instances.

##### Abstract Method Implementations

###### is_array_member

Parameters:

- `value`: The value that will be checked.

A member of TCEntityArray is a dictionary that must contain 'id', 'type', and 'value' keys. Additionally, the 'type' and
'id' keys should always map to a non-empty string.

The 'value' key is checked to be either an empty string or `None`.  The check for an empty 'value' key is performed in
`is_empty_member`. The check for a null 'value' key is performed in `is_null_member`.

This method raises and `InvalidMemberException` if `value` is not considered to be a member of TCEntityArray. Otherwise,
this method returns `True` if `value` meets the above conditions and returns `False` if it does not.

###### is_empty_member

Parameters:

- `value`: The value that will be checked.

An empty member of TCEntityArray is a value that passes the checks defined in `is_array_member` and whose 'value' key
maps to an empty string.

This method raises and `InvalidMemberException` if `value` is not considered to be a member of TCEntityArray. Otherwise,
this method returns `True` if `value` meets the above conditions and returns `False` if it does not.

##### Methods Extended From Superclass

###### is_null_member

Parameters:

- `value`: The value that will be checked.

A null member of TCEntityArray is a value that passes the checks defined in `is_array_member` and is either `None` or has
a 'value' key that is `None`.

This method raises and `InvalidMemberException` if `value` is not considered to be a member of TCEntityArray. Otherwise,
this method returns `True` if `value` meets the above conditions and returns `False` if it does not.

#### Intel Array

IntelArray is a HybridArray type that is composed of StringArray and TCEntityArray. Therefore, IntelArray may hold
both String and TCEntity instances.

##### Abstract Method Implementations

As IntelArray extends from AbstractHybridArray, the only abstract method that this class implements is the
`type_compositions` method.

###### type_compositions

IntelArray is composed of StringArray and TCEntityArray. Therefore, this method essentially returns
`[StringArray, TCEntityArray]`.

##### Special Methods

###### entities

IntelArray is a HybridArray made up of StringArray and TCEntityArray. If IntelArray were to ever hold a mix of
String and TCEntity instances, calling this method would filter out any String instances and yield only the
TCEntity instances within the IntelArray. Furthermore, if IntelArray has been customized with a `entity_filter_types`
value, only TCEntities that have a 'type' key whose value is found within `entity_filter_types` would be yielded.

See `custom_intel_array` documentation for more details.

###### values

Yields the unwrapped values of the members found within the IntelArray from which this method is called. If the member
is a String instance, the String instance is yielded. If the member is a TCEntity, then only the 'value' key of the
TCEntity would be yielded. In the end, this method produces a generator that is guaranteed to yield only String values.

#### Group Array

This type is a descendant of IntelArray. This means that GroupArray is a HybridArray that may hold both String and
TCEntity types as IntelArray does, except that GroupArray further checks that TCEntities have a 'type' that is a valid
Group type.

##### Methods Extended From Superclass

###### is_array_member

In addition to passing the checks provided in `AbstractHybridArray.is_array_member`, a value must also contain a 'type'
key that is one of the valid Group types (if value is a TCEntity) in order to be considered a member of GroupArray.

#### Indicator Array

This type is a descendant of IntelArray. This means that IndicatorArray is a HybridArray that may hold both String and
TCEntity types as IntelArray does, except that IndicatorArray further checks that TCEntities have a 'type' that is a
valid Indicator type.

##### Methods Extended From Superclass

###### is_array_member

In addition to passing the checks provided in `AbstractHybridArray.is_array_member`, a value must also contain a 'type'
key that is one of the valid Indicator types (if value is a TCEntity) in order to be considered a member of
IndicatorArray.

#### Customizable Arrays

Customizable Arrays allow the user to change the default behavior of Arrays. Some settings apply to all Array types, and
some settings are specific to certain Array types. Customizable Arrays are created using factory functions. The settings
that a user desires to customize should be passed as keyword arguments to the desired custom Array factory function.

There exists a customization factory function for each built-in Array type. If the user desires to customize a StringArray,
then `custom_string_array` should be used. If the user desires to customize a BinaryArray, then `custom_binary_array`
should be used, and so on.

The return type of custom Array factory functions are of the type that corresponds to each factory function, except
that `Custom` will be appended to the class name. For example, `custom_string_array` would return type StringArrayCustom
and `custom_string_array(optional=True)` would return type StringArrayOptionalCustom.

Any keyword arguments not documented here should be considered for internal use only, and users should never need to
provide values for them.

##### Global Settings

Settings that apply to all Array Types.

###### allow_empty_members

This customization keyword argument takes a boolean value and is `True` by default. When this value is `True` and the
Array is initialized with a list value, this flag decides if the list may contain empty members. The emptiness check
is different for each Array type. See `is_empty_member` method documentation of different Array types for details.

For example, if a StringArray is initialized with `['']`, then `allow_empty_members` would deem the aforementioned list
value as valid by default; however, if `allow_empty_members` is `False`, then a `ValueError` would be raised during
initialization.

Note that this option simply denotes whether the framework should inspect the values of a list that is used to initialize
an Array for emptiness. This value has no effect on whether the Array type will accept an empty list or an empty member.

Controlling whether the Array type will accept an empty list or an empty member is done via the `Optional` variant of the
Array. A custom Array factory function can be configured to return a customized `Optional` variant. See the `optional`
customization option for more details. `Optional` variants are described in the `Usage` section of this document.

###### allow_null_members

This customization keyword argument takes a boolean value and is `True` by default. When this value is `True` and the
Array is initialized with a list value, this flag decides if the list may contain empty members. The null check
is different for each Array type. See `is_null_member` method documentation of different Array types for details.

For example, if a StringArray is initialized with `[None]`, then `allow_null_members` would deem the aforementioned list
value as valid by default; however, if `allow_empty_members` is `False`, then a `ValueError` would be raised during
initialization.

Note that this option simply denotes whether the framework should inspect the values of a list that is used to initialize
an Array for null members. This value has no effect on whether the Array type will accept a null member.

Controlling whether the Array type will accept a null member (Typically `None`, but can vary depending on Array type.
See `is_null_member` method of different Array types for more details.) is described in the `Usage` section of this
document.

###### optional

This customization keyword argument takes a boolean value and is `False` by default. This keyword argument controls
whether the custom Array factory function will return a default variant of the Array being customized or an `Optional`
variant. For example, `custom_string_array(optional=True)` would result in a StringArrayOptionalCustom type, as opposed
to a StringArrayCustom type. For more information on `Optional` variants, see the `Usage` section of this document.

##### IntelArray Customizations

###### entity_filter_types

A list of String instances or `None`. By default, this option is set to `None`. If this value is not `None`, it must be
a list of String instances, and the String instances must all be valid Indicator or Group types. This customization
option alters the behavior of the `entities` method available in the IntelArray class (and available in GroupArray and
IndicatorArray by process of inheritance). See the `entities` method for more information.

##### GroupArray Customizations

###### entity_filter_types

This customization option works in the same way as the `entity_filter_types` customization option of `custom_intel_array`,
except that this value is restricted to only valid Group types when present.

##### IndicatorArray Customizations

###### entity_filter_types

This customization option works in the same way as the `entity_filter_types` customization option of `custom_intel_array`,
except that this value is restricted to only valid Indicator types when present.

##### StringArray Customizations

###### split

This customization takes a boolean value and is `False` by default. If this value is `True` and StringArray is initialized
with a single String value, the String value would be split on `,`. This option has no effect if StringArray is initialized
with an Array of Strings. This option is useful for inputs that must handle a single String, which could also be a
comma-separated values String.

Note: Enabling this customization results in the calling of the `split` method on the String value used to initialize
StringArray, which results in the String simply being split on `,` if `,` is present in the String.
This means that more complex CSV operations, like quote characters and escape characters, are not taken into account.
If more complex CSV splitting is desired, please refer to the `Content Parser` Playbook application.

###### strip_on_split

This customization option only has an effect when `split` is `True`. This option takes a boolean value and is
`True` by default. If this option is `True`, then `strip` will be called on the Strings that result from the `split`
operation. Therefore, if `split` is set to `True` and a StringArray is initialized with `one ,two, three, `, then the
StringArray will contain `['one', 'two', 'three']` in the end. Note that this has the additional side effect of removing
values that would be considered empty after the `strip` operation (`' '` is not be in the result, which would have come
from the empty space after `three,`).

If `strip_on_split` is `False`, then the end result would be: `['one ', 'two', ' three', ' ']`, which is simply the
result of the `split` operation.

## Singular Types

### Sensitive

This type should be used when an Integration requires sensitive data as an input, such as passwords, etc. Usage
of this type is as follows:

```
    class MyAction(BaseModel):
        """Model that defines inputs for Action 'My Action'"""

        # Define the expected type of input "My Input".
        my_sensitive_input: Sensitive
```

Within integration code, direct usage of `my_sensitive_input` results in a masked value (as in `******`). This is done
to prevent accidental logging of sensitive data. In order to access the real value of this field, one must access its
`value` property like so: `my_sensitive_input.value`.

This type may be initialized with String and Binary instances only.

This input type also has an `Optional` variant. See the `Usage` section of this document for more details about `Optional` variants.

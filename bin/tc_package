#!/usr/bin/env python

""" standard """
import argparse
import json
from setuptools.command import easy_install
""" third-party """
from jsonschema import SchemaError, ValidationError, validate
""" custom """
from tcex import TcEx

parser = argparse.ArgumentParser()
parser.add_argument(
    '--bundle', action='store_true', help='Build a bundle file.')
parser.add_argument(
    '--dryrun', action='store_true', help='Perform a dry run of the build.')
parser.add_argument(
    '--outpath', default='target', help='Location to write the outfile.')
parser.add_argument(
    '--validate', help='The install.json file to validate.')

# Load Schema
schema_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'tcex_json_schema.json')
with open(schema_file) as fh:
    schema = json.load(fh)

def main():
    """Package the app for deployment

    This method will package the app for deployment to ThreatConnect.  It will download
    all required dependencies and include them in the package.  Validating of the
    install.json file or files will be automatically run before packaging the app.
    """

    lib_directory = 'lib_{}.{}.{}'.format(
        sys.version_info.major, sys.version_info.minor, sys.version_info.micro)
    app_path = os.getcwd()
    contents = os.listdir(app_path)

    # create build directory
    tmp_path = os.path.join(os.sep, 'tmp', 'tcex_builds')
    if not os.path.isdir(tmp_path):
        os.mkdir(tmp_path)

    # copy project directory to temp location to use as template for multiple builds
    base_name = os.path.basename(app_path)
    template_app_path = os.path.join(tmp_path, base_name)
    if os.access(template_app_path, os.W_OK):
        # cleanup any previous failed builds
        shutil.rmtree(template_app_path)

    # ignore unwanted files from build to ensure app packages are minimum size
    ignore_patterns = shutil.ignore_patterns(
        '*.git*', 'lib', '*log', '*python-version', 'tc.json', '*.tcx')
    shutil.copytree(app_path, template_app_path, False, ignore_patterns)

    for install_json in contents:
        if 'install.json' not in install_json:
            continue

        self.validate(install_json)

        base_name = os.path.basename(app_path)
        if install_json == 'install.json':
            app_name = base_name
        else:
            app_name = install_json.split('.')[0]

        tmp_app_path = os.path.join(tmp_path, app_name)
        if tmp_app_path != template_app_path:
            shutil.copytree(template_app_path, tmp_app_path)

        lib_path = os.path.join(tmp_app_path, lib_directory)
        if os.access(lib_path, os.W_OK):
            shutil.rmtree(lib_path)
        os.mkdir(lib_path)

        os.environ['PYTHONPATH'] = '{0}'.format(lib_path)
        stdout = sys.stdout
        stderr = sys.stderr
        try:
            with open(os.path.join(app_path, '{}-package.log'.format(app_name)), 'w') as log:
                sys.stdout = log
                sys.stderr = log
                easy_install.main(['-axZ', '-d', lib_path, str(tmp_app_path)])
        except SystemExit as e:
            raise Exception(str(e))
        finally:
            sys.stdout = stdout
            sys.stderr = stderr

        if len(os.listdir(lib_path)) == 0:
            raise Exception('Encountered error running easy_install for {}.  Check log file for details.'.format(
                app_name))

        # cleanup
        git_path = os.path.join(tmp_app_path, '.git')
        if os.access(git_path, os.W_OK):
            shutil.rmtree(git_path)
        build_path = os.path.join(tmp_app_path, 'build')
        if os.access(build_path, os.W_OK):
            shutil.rmtree(build_path)

        # rename install.json
        if install_json != 'install.json':
            install_json_path = os.path.join(tmp_app_path, install_json)
            if os.access(build_path, os.W_OK):
                shutil.rmtree(install_json_path)
            shutil.move(install_json_path, os.path.join(tmp_app_path, 'install.json'))

        # zip build directory
        zip_file = os.path.join(app_path, app_name)
        if self._args.zip_out is not None and os.access(self._args.zip_out, os.W_OK):
            zip_file = os.path.join(self._args.zip_out, app_name)

        zip_file_zip = '{}.zip'.format(zip_file)
        zip_file_tcx = '{}.tcx'.format(zip_file)
        shutil.make_archive(zip_file, 'zip', tmp_path, app_name)
        shutil.move(zip_file_zip, zip_file_tcx)
        self._app_packages.append(zip_file_tcx)

        # cleanup build directory
        if install_json != 'install.json':
            shutil.rmtree(tmp_app_path)

    if self._args.collection and len(self._app_packages) > 0:
        collection_file = '{}.zip'.format(base_name)
        z = zipfile.ZipFile(collection_file, 'w')
        for app in self._app_packages:
            z.write(app, os.path.basename(app))
        z.close
        if self._args.zip_out is not None and os.access(self._args.zip_out, os.W_OK):
            collection_zip = os.path.join(self._args.zip_out, collection_file)
            shutil.move(collection_file, collection_zip)

    # cleanup template directory
    if os.access(template_app_path, os.W_OK):
        shutil.rmtree(template_app_path)
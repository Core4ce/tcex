#!/usr/bin/env python
# -*- coding: utf-8 -*-
""" TcEx Framework App Testing Module """
import argparse
import base64
import collections
import json
import logging
import os
import platform
import re
import sys
import subprocess
import time
import traceback

import colorama as c
import jmespath
from six import string_types

from tcex import TcEx

# Python 2 unicode
if sys.version_info[0] == 2:
    reload(sys)
    sys.setdefaultencoding('utf-8')

parser = argparse.ArgumentParser()
parser.add_argument(
    '--config', default='tcex.json', help='The configuration file. (default: "tcex.json")')
parser.add_argument(
    '--clear', action='store_true', help='Clear Redis data before running.')
parser.add_argument(
    '--halt_on_fail', action='store_true', help='Halt on any failure.')
parser.add_argument(
    '--group', default=None, help='The group of profiles to executed.')
parser.add_argument(
    '--logging_level', default='info', help='The logging level.')
parser.add_argument(
    '--profile', default='default', help='The profile to be executed. (default: "default")')
parser.add_argument(
    '--quiet', action='store_true', help='Suppress output.')
parser.add_argument(
    '--report', help='The JSON report filename.')
# parser.add_argument(
#     '--show_commands', action='store_true', help='Show staging and validation commands.')
parser.add_argument(
    '--unmask', action='store_true', help='Unmask masked args.')
parser.add_argument(
    '--gen_launcher', action='store_true', help='Generate Visual Studio Code launcher config.')
args, extra_args = parser.parse_known_args()


# TODO: Clean this up when time allows
class TcRun(object):
    """Run profiles for App"""

    def __init__(self, _args):
        """ """
        self._args = _args
        self._config = None
        self._install_json = None
        self._profile = {}
        self.reports = Reports()
        self.tcex = None

        # logger
        self.log = self._logger()

        self.app_path = os.getcwd()
        self.exit_code = 0
        self.json_report = {}
        self.sleep = 1
        # data from install.json
        self.display_name = None
        self.program_main = None
        self.program_version = None
        self.runtime_level = None

        self.shell = False
        if platform.system() == 'Windows':
            self.shell = True

        # initialize colorama
        c.init(autoreset=True, strip=False)

    def _load_config_include(self, include_directory):
        """Load included configuration files."""
        include_directory = os.path.join(self.app_path, include_directory)
        if not os.path.isdir(include_directory):
            msg = 'Provided include directory does not exist ({}).'.format(include_directory)
            sys.exit(msg)

        profiles = []
        for file in sorted(os.listdir(include_directory)):
            if file.endswith('.json'):
                print('Include File: {}{}{}'.format(c.Style.BRIGHT, c.Fore.MAGENTA, file))
                config_file = os.path.join(include_directory, file)
                with open(config_file) as data_file:
                    try:
                        profiles.extend(json.load(data_file))
                    except ValueError as e:
                        print('Invalid JSON file: {}{}{}'.format(c.Style.BRIGHT, c.Fore.RED, e))
                        sys.exit(1)
        return profiles

    def _logger(self):
        """Create logger instance.

        Returns:
            logger: An instance of logging
        """
        log_level = {
            'debug': logging.DEBUG,
            'info': logging.INFO,
            'warning': logging.WARNING,
            'error': logging.ERROR,
            'critical': logging.CRITICAL
        }
        level = log_level.get(self._args.logging_level.lower())

        # Formatter
        tx_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s '
        tx_format += '(%(funcName)s:%(lineno)d)'
        formatter = logging.Formatter(tx_format)

        # Logger
        log = logging.getLogger('tcrun')

        # # Stream Handler
        # sh = logging.StreamHandler()
        # sh.set_name('sh')
        # sh.setLevel(level)
        # sh.setFormatter(formatter)
        # log.addHandler(sh)

        # File Handler
        logfile = os.path.join('log', 'run.log')
        fh = logging.FileHandler(logfile)
        fh.set_name('fh')
        fh.setLevel(logging.DEBUG)
        fh.setFormatter(formatter)
        log.addHandler(fh)

        log.setLevel(level)
        log.info('Logging Level: {}'.format(logging.getLevelName(level)))
        return log

    @property
    def config(self):
        """Return configuration data.

        Load on first access, otherwise return existing data.
        """
        if self._config is None:
            if not os.path.isfile(self._args.config):
                msg = 'Provided config file does not exist ({}).'.format(self._args.config)
                sys.exit(msg)

            print('Configuration File: {}{}{}'.format(
                c.Style.BRIGHT, c.Fore.CYAN, self._args.config))
            with open(self._args.config) as data_file:
                self._config = json.load(data_file)

            # load includes
            for directory in self._config.get('profile_include_dirs', []):
                self._config.setdefault('profiles', []).extend(self._load_config_include(directory))
        return self._config

    def load_install_json(self, filename):
        """Return install.json data.

        Load on first access, otherwise return existing data.
        """
        if self._install_json is None:
            load_output = 'Load install.json: {}{}{}{}'.format(
                c.Style.BRIGHT, c.Fore.CYAN, filename, c.Style.RESET_ALL)
            if filename is not None and os.path.isfile(filename):
                with open(filename) as config_data:
                    self._install_json = json.load(config_data)
                load_output += ' {}{}(Loaded){}'.format(
                    c.Style.BRIGHT, c.Fore.GREEN, c.Style.RESET_ALL)
            else:
                load_output += ' {}{}(Not Found){}'.format(
                    c.Style.BRIGHT, c.Fore.YELLOW, c.Style.RESET_ALL)

            # display load status
            print(load_output)

            # self.display_name = install_json.get('displayName')
            # self.program_main = install_json.get('programMain')
            # self.program_version = install_json.get('programVersion')
            # self.runtime_level = install_json.get('runtimeLevel')
            # self._install_json = install_json
        return self._install_json

    # @staticmethod
    # def data_args(arg_data):
    #     """Get just the args required for data services"""
    #     return {
    #         'api_access_id': arg_data.get('api_access_id'),
    #         'api_secret_key': arg_data.get('api_secret_key'),
    #         'tc_log_level': arg_data.get('tc_log_level', arg_data.get('logging', 'debug')),
    #         'tc_api_path': arg_data.get('tc_api_path'),
    #         'tc_log_file': 'data.log',
    #         'tc_log_path': arg_data.get('tc_log_path'),
    #         'tc_out_path': arg_data.get('tc_out_path'),
    #         'tc_playbook_db_context': arg_data.get('tc_playbook_db_context'),
    #         'tc_playbook_db_path': arg_data.get('tc_playbook_db_path'),
    #         'tc_playbook_db_port': arg_data.get('tc_playbook_db_port'),
    #         'tc_playbook_db_type': arg_data.get('tc_playbook_db_type'),
    #         'tc_temp_path': arg_data.get('tc_temp_path')
    #     }

    @property
    def tcex_required_args(self):
        """Get just the args required for data services"""
        return [
            'api_access_id',
            'api_secret_key',
            # 'tc_log_level',
            'tc_api_path',
            'tc_log_file',
            'tc_log_path',
            'tc_out_path',
            'tc_playbook_db_context',
            'tc_playbook_db_path',
            'tc_playbook_db_port',
            'tc_playbook_db_type',
            'tc_proxy_external',
            'tc_proxy_host',
            'tc_proxy_port',
            'tc_proxy_password',
            'tc_proxy_tc',
            'tc_proxy_username',
            'tc_temp_path'
        ]

    def load_tcex(self):
        """Inject required TcEx CLI Args."""
        sys.argv = [sys.argv[1]]  # reset sys.argv
        for arg, value in self.profile.get('profile_args', {}).data.items():
            if arg not in self.tcex_required_args:
                continue
            # add new log file name and level
            sys.argv.extend(['--tc_log_file', 'data.log'])
            sys.argv.extend(['--tc_log_level', 'error'])
            # format key
            arg = '--{}'.format(arg)
            if isinstance(value, (bool)):
                # handle bool values as flags (e.g., --flag) with no value
                if value:
                    sys.argv.append(arg)
            else:
                sys.argv.append(arg)
                sys.argv.append('{}'.format(value))
        self.tcex = TcEx()

    def path_data(self, variable_data, path):
        """Return jmespath data."""
        if isinstance(variable_data, string_types):
            # try to convert string into list/dict before using expression
            try:
                variable_data = json.loads(variable_data)
            except Exception:
                self.log.debug('String value ({}) could not JSON serialized.'.format(
                    variable_data))
        if path is not None and isinstance(variable_data, (dict, list)):
            expression = jmespath.compile(path)
            variable_data = expression.search(
                variable_data, jmespath.Options(dict_cls=collections.OrderedDict))
        return variable_data

    def clear(self):
        """Clear Redis and ThreatConnect data defined in profile.

        Redis Data:
        {
          "data_type": "redis",
          "variable": "#App:4768:tc.adversary!TCEntity"
        }

        ThreatConnect Data:
        {
          "data_type": "threatconnect",
          "owner": "TCI",
          "type": "Address",
          "value": "1.1.1.1"
        }
        """
        for clear_data in self.profile.get('clear', []):
            if clear_data.get('data_type') == 'redis':
                variable = clear_data.get('variable')
                self.log.info('[clear] Deleting redis variable: {}.'.format(variable))
                print('Clearing Variables: {}{}{}'.format(c.Style.BRIGHT, c.Fore.MAGENTA, variable))
                self.tcex.playbook.delete(variable)
            elif clear_data.get('data_type') == 'threatconnect':
                batch = self.tcex.batch(clear_data.get('owner'), action='Delete')
                tc_type = clear_data.get('type')
                path = clear_data.get('path')
                if clear_data.get('type') in self.tcex.group_types:
                    name = self.tcex.playbook.read(clear_data.get('name'))
                    # json path name
                    name = self.path_data(name, path)
                    if name is not None:
                        print('Deleting ThreatConnect Group: {}{}{}'.format(
                            c.Style.BRIGHT, c.Fore.MAGENTA, name))
                        self.log.info('[clear] Deleting ThreatConnect {} with name: {}.'.format(
                            tc_type, name))
                        batch.group(clear_data.get('type'), clear_data.get('name'))
                elif clear_data.get('type') in self.tcex.indicator_types:
                    value = self.tcex.playbook.read(clear_data.get('value'))
                    value = self.path_data(value, path)
                    if value is not None:
                        print('Deleting ThreatConnect Indicator: {}{}{}'.format(
                            c.Style.BRIGHT, c.Fore.MAGENTA, value))
                        self.log.info('[clear] Deleting ThreatConnect {} with value: {}.'.format(
                            tc_type, value))
                        batch.indicator(clear_data.get('type'), clear_data.get('value'))
                batch.submit()

    def stage(self):
        """Stage Redis and ThreatConnect data defined in profile.

        Redis Data:
        {
            "data": [
                "This is an example Source #1",
                "This is an example Source #2"
            ],
            "variable": "#App:1234:source!StringArray"
        }

        Redis Array:
        {
            "data": {
                "variables": [{
                    "value": "#App:4768:tc.adversary!TCEntity",
                }, {
                    "value": "#App:4768:tc.threat!TCEntity",
                }]
            },
            "data_type": "redis_array",
            "variable": "#App:4768:groups!TCEntityArray"
        },
        {
            "data": {
                "variables": [{
                    "value": "#App:4768:tc.adversary!TCEntity",
                    "path": ".name"
                }, {
                    "value": "#App:4768:tc.threat!TCEntity",
                    "path": ".name"
                }]
            },
            "data_type": "redis_array",
            "variable": "#App:4768:groups!StringArray"
        }

        ThreatConnect Data:
        {
            "data": {
                "group": [{
                    "firstSeen": "2008-12-12T12:00:00Z",
                    "name": "campaign-002",
                    "type": "Campaign",
                    "xid": "camp-0002",
                    "attribute": [{
                        "displayed": True,
                        "type": "Description",
                        "value": "Campaign Example Description"
                    }],
                    "tag": [{
                        "name": "SafeToDelete"
                    }],
                    "variable": "#App:4768:tc.campaign!TCEntity"
                }],
                "indicator": [{
                    "associatedGroups": [
                        {
                            "groupXid": "campaign-002"
                        }
                    ],
                    "confidence": 100,
                    "fileOccurrence": [
                        {
                            "date": "2017-02-02T01:02:03Z",
                            "fileName": "drop1.exe",
                            "path": "C:\\test\\"
                        }
                    ],
                    "rating": 5.0,
                    "summary": "43c3609411c83f363e051d455ade78a6",
                    "tag": [
                        {
                            "name": "SafeToDelete"
                        }
                    ],
                    "type": "File",
                    "xid": "55ee19565db5b16a0f511791a3b2a7ef0ccddf4d9d64e7008561329419cb675b",
                    "variable": "#App:4768:tc.file!TCEntity"
                }]
            },
            "data_owner": "TCI",
            "data_type": "threatconnect"
        }
        """
        for sd in self.staging_data:
            data_type = sd.get('data_type', 'redis')
            if data_type == 'redis':
                self.log.debug('Stage Redis Data')
                self.stage_redis(sd.get('variable'), sd.get('data'))
            elif data_type == 'threatconnect':
                self.log.debug('Stage ThreatConnect Data')
                self.stage_tc(sd.get('data_owner'), sd.get('data', {}))
            elif data_type == 'redis_array':
                self.log.debug('Stage Redis Array')
                out_variable = sd.get('variable')
                # build array
                redis_array = []
                for var in sd.get('data', {}).get('variables', []):
                    variable = var.get('value')
                    data = self.path_data(self.tcex.playbook.read(variable), var.get('path'))
                    # TODO: should None value be appended?
                    redis_array.append(data)
                self.stage_redis(out_variable, redis_array)
                # print(redis_array)

    @property
    def staging_data(self):
        """Read data files and return all staging data for current profile."""
        staging_data = []
        for staging_file in self.profile.get('data_files', []):
            if os.path.isfile(staging_file):
                print('Staging Data: {}{}{}'.format(c.Style.BRIGHT, c.Fore.MAGENTA, staging_file))
                f = open(staging_file, 'r')
                staging_data.extend(json.load(f))
                f.close()
            else:
                print('{}{}Could not find file {}.'.format(
                    c.Style.BRIGHT, c.Fore.RED, staging_file))
        return staging_data

    def stage_redis(self, variable, data):
        """Stage Redis Data"""
        if isinstance(data, int):
            data = str(data)
        if variable.endswith('Binary'):
            data = base64.b64decode(data)
        self.log.info(u'[stage] Creating variable {}'.format(variable))
        self.tcex.playbook.create(variable, data)

    def stage_tc(self, owner, staging_data):
        """Stage Redis Data"""
        batch = self.tcex.batch(owner)
        for group in staging_data.get('group', []):
            # add to redis
            variable = group.pop('variable', None)
            path = group.pop('path', None)
            data = self.path_data(group, path)
            if variable is not None and data is not None:
                self.stage_redis(variable, data)
            # add to batch
            batch.add_group(group)
        for indicator in staging_data.get('indicator', []):
            # add to redis
            variable = indicator.pop('variable', None)
            path = indicator.pop('path', None)
            # add to batch after extra data has been popped
            batch.add_indicator(indicator)
            data = self.path_data(dict(indicator), path)
            if variable is not None and data is not None:
                if isinstance(data, (dict)):
                    # tcentity uses value as the name
                    data['value'] = data.pop('summary')
                self.stage_redis(variable, data)
        # print(batch)
        # submit batch
        batch_results = batch.submit()
        for error in batch_results.get('errors', []):
            self.log.error(error)

    @staticmethod
    def _create_tc_dirs(profile):
        """Create app directories for logs and data files."""
        tc_log_path = profile.get('args', {}).get('tc_log_path')
        if tc_log_path is not None and not os.path.isdir(tc_log_path):
            os.makedirs(tc_log_path)
        tc_out_path = profile.get('args', {}).get('tc_out_path')
        if tc_out_path is not None and not os.path.isdir(tc_out_path):
            os.makedirs(tc_out_path)
        tc_tmp_path = profile.get('args', {}).get('tc_tmp_path')
        if tc_tmp_path is not None and not os.path.isdir(tc_tmp_path):
            os.makedirs(tc_tmp_path)

    @property
    def profile(self):
        """Return the current profile."""
        return self._profile

    @profile.setter
    def profile(self, profile):
        """Set the current profile."""
        # retrieve language from install.json or assume Python
        lang = profile.get('install_json', {}).get('programLanguage', 'PYTHON')
        # load instance of ArgBuilder
        profile_args = ArgBuilder(lang, profile.get('args'))
        # set current profile
        self._profile = profile
        # attach instance to current profile
        self._profile['profile_args'] = profile_args
        # load tcex module after current profile is set
        self.load_tcex()

    @property
    def profiles(self):
        """Return all selected profiles."""
        selected_profiles = []
        for config in self.config.get('profiles'):

            profile_selected = False
            profile_name = config.get('profile_name')

            if profile_name == self._args.profile:
                profile_selected = True
            elif config.get('group') is not None and config.get('group') == self._args.group:
                profile_selected = True
            elif self._args.group in config.get('groups', []):
                profile_selected = True

            if profile_selected:
                install_json_filename = config.get('install_json')
                ij = {}
                if install_json_filename is not None:
                    ij = self.load_install_json(install_json_filename)
                config['install_json'] = ij
                selected_profiles.append(config)

            report = self.reports.add_profile(config, profile_selected)

        if not selected_profiles:
            print('{}{}No profiles selected to run.'.format(c.Style.BRIGHT, c.Fore.YELLOW))

        return selected_profiles

    def run(self):
        """Run the App using the current profile.

        The current profile has the install_json and args pre-loaded.
        """
        install_json = self.profile.get('install_json')
        program_language = self.profile.get('install_json').get('programLanguage', 'python').lower()
        # select report for current profile
        self.reports.profile(self.profile.get('profile_name'))

        print('{}{}'.format(c.Style.BRIGHT, '-' * 100))

        if install_json.get('programMain') is not None:
            program_main = install_json.get('programMain').replace('.py', '')
        elif self.profile.get('script') is not None:
            program_main = self.profile.get('script').replace('.py', '')
        else:
            print('{}{}No Program Main or Script defined.'.format(c.Style.BRIGHT, c.Fore.RED))
            sys.exit(1)

        self.run_display_profile(program_main)
        self.run_display_description()
        self.run_validate_program_main(program_main)

        # build the command
        if program_language == 'python':
            command = [
                sys.executable,
                '.',
                program_main
            ]
        elif program_language == 'java':
            command = [
                self.config.get('java_path', program_language),
                '-cp',
                sp.get('class_path', './target/*')
            ]
            # exe_command = command + parameters.get('unmasked') + [self.program_main]
            # print_command = ' '.join(command + parameters.get('masked') + [self.program_main])

        exe_command = command + self.profile.get('profile_args').standard
        print_command = ' '.join(command + self.profile.get('profile_args').masked)
        self.log.info('[run] Running command {}'.format(print_command))

        # output command
        print('Executing: {}{}{}'.format(c.Style.BRIGHT, c.Fore.GREEN, print_command))

        # Run Command
        p = subprocess.Popen(
            exe_command, shell=self.shell, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
        out, err = p.communicate()

        # Exit Code
        self.run_exit_code(p.returncode, out, err)

    def run_display_profile(self, program_main):
        """Print profile name with programMain."""
        install_json = self.profile.get('install_json')

        output = 'Profile: '
        output += '{}{}{}{} '.format(
            c.Style.BRIGHT, c.Fore.CYAN, self.profile.get('profile_name'), c.Style.RESET_ALL)
        output += '[{}{}{}{}'.format(
            c.Style.BRIGHT, c.Fore.MAGENTA, program_main, c.Style.RESET_ALL)
        if self.program_version is not None:
            output += '{}:{}'.format(
                c.Style.BRIGHT, c.Style.RESET_ALL)
            output += '{}{}{}{}'.format(
                c.Style.BRIGHT, c.Fore.MAGENTA, install.get('programVersion'), c.Style.RESET_ALL)
        output += ']'
        print(output)

    def run_display_description(self):
        """Print profile name with programMain."""
        # display description if available
        if self.profile.get('description'):
            print('Description: {}{}{}'.format(
                c.Style.BRIGHT, c.Fore.MAGENTA, self.profile.get('description')))

    def run_exit_code(self, returncode, out, err):
        """Handle the exit code for the current run."""
        if not self.profile.get('quiet') and not self._args.quiet:
            print('App Output:')
            for o in out.decode('utf-8').split('\n'):
                print('  {}{}{}'.format(c.Style.BRIGHT, c.Fore.CYAN, o))

        self.reports.increment_total()
        valid_exit_codes = self.profile.get('exit_codes', [0])
        self.reports.exit_code = returncode
        execution_result = 'fail'
        if returncode in valid_exit_codes:
            self.reports.profile_execution(True)
            print('App Exit Code: {}{}{}'.format(c.Style.BRIGHT, c.Fore.GREEN, returncode))
        else:
            self.reports.profile_execution(False)
            print('App Exit Code: {}{}{}{} (Valid Exit Codes: {})'.format(
                c.Style.BRIGHT, c.Fore.RED, returncode, c.Fore.RESET, valid_exit_codes))
            if err is not None and err:
                print('{}{}{}'.format(c.Style.BRIGHT, c.Fore.RED, err))
            self.exit_code = 1
            if args.halt_on_fail:
                sys.exit(1)

    def run_validate_program_main(self, program_main):
        """Validate the program main file exists."""
        program_language = self.profile.get('install_json').get('programLanguage', 'python').lower()
        if program_language == 'python' and not os.path.isfile('{}.py'.format(program_main)):
            print('{}{}Could not find program main file ({}).'.format(
                c.Style.BRIGHT, c.Fore.RED, program_filename))
            sys.exit(1)

    # def run(self):
    #     """Run the App using the defined config."""
    #     # load tc config
    #     self._load_config()
    #     self.json_report = {
    #         'profiles': [],
    #         'run_config': {
    #             'provided_group': self._args.group,
    #             'provided_profile': self._args.profile,
    #             'selected_profiles': []
    #         },
    #         'run_status': {
    #             'total': 0,
    #             'executions': {
    #                 'pass': 0,
    #                 'fail': 0
    #             },
    #             'validations': {
    #                 'pass': 0,
    #                 'fail': 0
    #             }
    #         }
    #     }


    #     command_count = 0
    #     reports = []  # output to terminal
    #     for profile_data in selected_profiles:
    #         sp = profile_data.get('config')
    #         report_profile = profile_data.get('report_profile')

    #         # create temp directories
    #         self._create_tc_dirs(sp)

    #         # status trackers
    #         execution_success = False
    #         validation_success = False

    #         # cleanup old redis data
    #         if args.clear:
    #             self.clear_data(sp)

    #         # use globally configured sleep time or per profile sleep time (default self.sleep)
    #         if command_count > 0:
    #             sleep = sp.get('sleep', self.config.get('sleep', self.sleep))
    #             print('Sleep: {}{}{} seconds'.format(c.Style.BRIGHT, c.Fore.YELLOW, sleep))
    #             time.sleep(sleep)

    #         command_count += 1

    #         # divider (add after sleep since sleep only runs after first profile)
    #         print('{}{}'.format(c.Style.BRIGHT, '-' * 100))

    #         # load install_json (if provided)
    #         self._load_install_json(sp.get('install_json'))
    #         program_language = self.install_json.get('programLanguage', 'python').lower()

    #         # if install.json provided use programMain, otherwise use script name from tcex.json
    #         # eventually install.json should be required and script will be removed from tcex.json
    #         if self.program_main is not None:
    #             program_main = self.program_main.replace('.py', '')
    #         elif sp.get('script') is not None:
    #             program_main = sp.get('script').replace('.py', '')
    #         else:
    #             print('{}{}No Program Main or Script defined.'.format(c.Style.BRIGHT, c.Fore.RED))
    #             sys.exit(1)

    #         # Display Output with App data
    #         output = 'Profile: '
    #         output += '{}{}{}{} '.format(
    #             c.Style.BRIGHT, c.Fore.CYAN, sp.get('profile_name'), c.Style.RESET_ALL)
    #         output += '[{}{}{}{}'.format(
    #             c.Style.BRIGHT, c.Fore.MAGENTA, program_main, c.Style.RESET_ALL)
    #         if self.program_version is not None:
    #             output += '{}:{}'.format(
    #                 c.Style.BRIGHT, c.Style.RESET_ALL)
    #             output += '{}{}{}{}'.format(
    #                 c.Style.BRIGHT, c.Fore.MAGENTA, self.program_version, c.Style.RESET_ALL)
    #         output += ']'
    #         print(output)
    #         if sp.get('description'):
    #             print('Description: {}{}{}'.format(
    #                 c.Style.BRIGHT, c.Fore.MAGENTA, sp.get('description')))

    #         #
    #         # Stage Data
    #         #
    #         self.stage_data(sp)

    #         program_filename = program_main
    #         if program_language == 'python':
    #             # for python apps append the ".py" extension to the filename
    #             program_filename = '{}.py'.format(program_main)

    #         # validate the program main file exists only for python.  for java apps the program main
    #         # is not a file.
    #         if program_language == 'python' and not os.path.isfile(program_filename):
    #             print('{}{}Could not find program main file ({}).'.format(
    #                 c.Style.BRIGHT, c.Fore.RED, program_filename))
    #             sys.exit(1)

    #         # build command line arguments
    #         parameters = self.parameters(sp.get('args'))

    #         # build the command
    #         if program_language == 'python':
    #             command = [
    #                 sys.executable,
    #                 '.',
    #                 program_main
    #             ]
    #             exe_command = command + parameters.get('unmasked')
    #             print_command = ' '.join(command + parameters.get('masked'))
    #         elif program_language == 'java':
    #             command = [
    #                 self.config.get('java_path', program_language),
    #                 '-cp',
    #                 sp.get('class_path', './target/*')
    #             ]
    #             exe_command = command + parameters.get('unmasked') + [self.program_main]
    #             print_command = ' '.join(command + parameters.get('masked') + [self.program_main])

    #         # output command
    #         print('Executing: {}{}{}'.format(c.Style.BRIGHT, c.Fore.GREEN, print_command))

    #         #
    #         # Run Command
    #         #
    #         p = subprocess.Popen(
    #             exe_command, shell=self.shell, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    #             stderr=subprocess.PIPE)
    #         out, err = p.communicate()

    #         #
    #         # Logs
    #         #
    #         # log_directory = os.path.join(self.app_path, sp.get('args').get('tc_log_path'))
    #         # for log_file in os.listdir(log_directory):
    #         #     log_file = os.path.join(log_directory, log_file)
    #         #     print('Logs: {}{}{}'.format(
    #         #         self.BOLD_CYAN, log_file, self.DEFAULT))

    #         #
    #         # Script Output
    #         #
    #         if not sp.get('quiet') and not self._args.quiet:
    #             print(self.to_string(out, 'ignore'))

    #         #
    #         # Exit Code
    #         #
    #         self.json_report['run_status']['total'] += 1
    #         valid_exit_codes = sp.get('exit_codes', [0])
    #         report_profile['exit_code'] = p.returncode
    #         execution_result = 'fail'
    #         if p.returncode in valid_exit_codes:
    #             print('App Exit Code: {}{}{}'.format(c.Style.BRIGHT, c.Fore.GREEN, p.returncode))
    #             execution_result = 'pass'
    #             execution_success = True
    #         else:
    #             print('App Exit Code: {}{}{}{} (Valid Exit Codes: {})'.format(
    #                 c.Style.BRIGHT, c.Fore.RED, p.returncode, c.Fore.RESET, valid_exit_codes))
    #             if err is not None and err:
    #                 print('{}{}{}'.format(c.Style.BRIGHT, c.Fore.RED, err))
    #             self.exit_code = 1
    #             if args.halt_on_fail:
    #                 break
    #         self.json_report['run_status']['executions'][execution_result] += 1

    #         #
    #         # Validate Data
    #         #
    #         validation_result = 'fail'
    #         if execution_success:
    #             validation_success = self.validate_data(sp)
    #             if validation_success:
    #                 validation_result = 'pass'
    #         self.json_report['run_status']['validations'][validation_result] += 1

    #         #
    #         # Error Output
    #         #
    #         if err:
    #             print(err.decode('utf-8'))

    #         # updated status in report
    #         reports.append({
    #             'profile': sp.get('profile_name'),
    #             'execution_success': execution_success,
    #             'validation_success': validation_success
    #         })
    #         # update report
    #         report_profile['execution_success'] = execution_success
    #         report_profile['validation_success'] = validation_success
    #         self.json_report['profiles'].append({
    #             sp.get('profile_name'): report_profile
    #         })

    #     #
    #     # Reports
    #     #
    #     if args.report:
    #         with open(args.report, 'w') as outfile:
    #             json.dump(self.json_report, outfile, sort_keys=True)

    #     # on screen report
    #     if reports:
    #         self.report(reports)

    # @staticmethod
    # def report(data):
    #     """Format and output report data to screen."""
    #     print('\n{}{}{}'.format(c.Style.BRIGHT, c.Fore.CYAN, 'Report:'))
    #     print('{0!s:<60}{1!s:<25}{2!s:<25}'.format('Profile:', 'Execution:', 'Validation:'))
    #     for d in data:
    #         profile = d.get('profile')
    #         execution_color = c.Fore.RED
    #         execution_text = 'Failed'
    #         if d.get('execution_success'):
    #             execution_color = c.Fore.GREEN
    #             execution_text = 'Passed'

    #         validation_color = c.Fore.RED
    #         validation_text = 'Failed'
    #         if d.get('validation_success'):
    #             validation_color = c.Fore.GREEN
    #             validation_text = 'Passed'

    #         print('{0!s:<60}{1}{2}{3!s:<25}{4}{5!s:<25}'.format(
    #             profile, c.Style.BRIGHT, execution_color, execution_text, validation_color,
    #             validation_text))

    def gen_launcher(self):
        """
        {
            "name": "Python3: TcEx Local App",
            "type": "python",
            "request": "launch",
            "program": "${workspaceFolder}/datetime_format.py",
            "pythonPath": "/Users/bsummers/.pyenv/shims/python",
            "args": [
                "--tc_temp_path",
                "log",
                "--tc_out_path",
                "log",
                "--tc_terminate_seconds",
                "600",
                "--tc_aot_enabled",
                "--api_secret_key",
                "'hIW18fN9DfxTKk2ANJ1bmC?Do0f5n6Ba1$E71MhEeG6EkkUXuh0KNQMBAAF3BufS'",
                "--tc_playbook_db_path",
                "localhost",
                "--date_input",
                "'#App:8141:time_inputs!StringArray'",
                "--api_access_id",
                "55808334917504999748",
                "--tc_exit_channel",
                "'aot-dateformat-exit'",
                "--tc_playbook_db_type",
                "Redis",
                "--date_offset",
                "'-1 year -1 month -1 day'",
                "--api_default_org",
                "TCI",
                "--date_timezone",
                "UTC",
                "--tc_log_path",
                "log",
                "--date_format",
                "'%Y-%m-%dT%H:%M:%SZ'",
                "--tc_playbook_db_context",
                "'4bfb97c8-aee9-486a-aa77-811c32b5a2c8'",
                "--tc_api_path",
                "https://app.tci.ninja/api",
                "--tc_playbook_db_port",
                "6379",
                "--tc_action_channel",
                "'aot-dateformat'",
                "--fail_on_error",
                "--tc_log_level",
                "debug",
                "--tc_playbook_out_variables",
                "'#App:7470:datetime.format.json!String,#App:7470:datetime.format.count.pass!String,
                  #App:7470:datetime.format.count.fail!String,
                  #App:7470:datetime.format.input!StringArray,
                  #App:7470:datetime.format.offset!String,#App:7470:datetime.format.strftime!String,
                  #App:7470:datetime.format.formatted_dates.0!String,
                  #App:7470:datetime.format.formatted_dates!StringArray,
                  #App:7470:datetime.format.timezone!String'"
            ],
        },
        """
        program = self.profile.get(
            'install_json', {}).get('programMain', self.profile.get('script'))
        print(json.dumps({
            'name': 'TcRun: {}'.format(self.profile.get('profile_name')),
            'type': 'python',
            'request': 'launch',
            'program': '${workspaceFolder}/' + '{}.py'.format(program),
            #'pythonPath': '/Users/bsummers/.pyenv/shims/python',
            'args': self.profile.get('profile_args').standard
        }, indent=4))


class ArgBuilder(object):
    """Build CLI Args"""

    def __init__(self, lang, _args):
        self.lang = lang.lower()
        self._data = {}
        self._args = []
        self._args_masked = []
        self._args_quoted = []
        # Build arg data
        self.load(_args)

    @property
    def data(self):
        """Return all data formatted for the provided language."""
        return self._data

    @property
    def masked(self):
        """Return all args formatted for the provided language."""
        return self._args_masked

    @property
    def quoted(self):
        """Return all args formatted for the provided language."""
        return self._args_quoted

    @property
    def standard(self):
        """Return all args formatted for the provided language."""
        return self._args

    def _add_arg_python(self, key, value=None, mask=False):
        """Add CLI Arg formatted specifically for Python.

        Args:
            key (string): The CLI Args key (e.g., --name).
            value (string): The CLI Args value (e.g., bob).
            mask (boolean, default:False): Indicates whether no mask value.
        """
        if value is False:
            # boolean values are flags and should only be included when True
            return
        self._data[key] = value
        self._args.append('--{}'.format(key))
        self._args_quoted.append('--{}'.format(key))
        self._args_masked.append('--{}'.format(key))
        if value is not True:
            # boolean values are flags and cli arg should not have a value
            self._args.append(value)
            self._args_quoted.append(self.quote(value))
            if mask:
                value = 'x' * len(str(value))
            else:
                value = self.quote(value)
            self._args_masked.append(value)

    def _add_arg_java(self, key, value, mask=False):
        """Add CLI Arg formatted specifically for Java.

        Args:
            key (string): The CLI Args key (e.g., --name).
            value (string): The CLI Args value (e.g., bob).
            mask (boolean, default:False): Indicates whether no mask value.
        """
        if isinstance(value, bool):
            value = int(value)
        self._args.append('{}{}={}'.format('-D', key, value))
        self._args_quoted.append(self.quote('{}{}={}'.format('-D', key, value)))
        if mask:
            value = 'x' * len(str(value))
        self._args_masked.append('{}{}={}'.format('-D', key, value))

    def _add_arg(self, key, value, mask=False):
        """Add CLI Arg for the correct language.

        Args:
            key (string): The CLI Args key (e.g., --name).
            value (string): The CLI Args value (e.g., bob).
            mask (boolean, default:False): Indicates whether no mask value.
        """
        if self.lang == 'python':
            self._add_arg_python(key, value, mask)
        elif self.lang == 'java':
            self._add_arg_java(key, value, mask)

    def add(self, key, value):
        """Add CLI Arg to lists value.

        Args:
            key (string): The CLI Args key (e.g., --name).
            value (string): The CLI Args value (e.g., bob).
        """
        if isinstance(value, list):
            # TODO: support env vars in list w/masked values
            for val in value:
                self._add_arg_python(key, val)
        elif isinstance(value, dict):
            err = 'Dictionary types are not currently supported for field.'
            print('{}{}{}'.format(c.Style.BRIGHT, c.Fore.RED, err))
        else:
            mask = False
            env_var = re.compile(r'^\$env\.(.*)$')
            envs_var = re.compile(r'^\$envs\.(.*)$')

            if env_var.match(str(value)):
                # read value from environment variable
                env_key = env_var.match(str(value)).groups()[0]
                value = os.environ.get(env_key, value)
            elif envs_var.match(str(value)):
                # read secure value from environment variable
                env_key = envs_var.match(str(value)).groups()[0]
                value = os.environ.get(env_key, value)
                mask = True
            self._add_arg(key, value, mask)

    def quote(self, data):
        """Quote any parameters that contain spaces or special character

        Returns:
            (string): String containing parameters wrapped in double quotes
        """
        if self.lang == 'python':
            quote_char = '\''
        elif self.lang == 'java':
            quote_char = '\''

        if re.findall(r'[!\-\s\$]{1,}', str(data)):
            data = '{}{}{}'.format(quote_char, data, quote_char)
        return data

    def load(self, profile_args):
        """Load provided CLI Args.

        Args:
            args (dict): Dictionary of args in key/value format.
        """
        for key, value in profile_args.items():
            self.add(key, value)


class Report(object):
    """Report Object for a single profile."""

    def __init__(self, profile):
        """Initialize class properties."""
        self.data = {
            'description': profile.get('description'),
            'groups': profile.get('groups'),
            'name': profile.get('profile_name'),
            'selected': False,
            'valid_exit_codes': profile.get('exit_codes')
        }

    @property
    def execution_success(self):
        """Return the profile/report execution_success."""
        return self.data.get('execution_success')

    @execution_success.setter
    def execution_success(self, execution_success):
        """Set the profile/report execution_success."""
        self.data['execution_success'] = execution_success

    @property
    def exit_code(self):
        """Return the profile/report exit_code."""
        return self.data.get('exit_code')

    @exit_code.setter
    def exit_code(self, exit_code):
        """Set the profile/report exit_code."""
        self.data['exit_code'] = exit_code

    @property
    def name(self):
        """Return the profile/report name."""
        return self.data.get('name')

    @property
    def selected(self):
        """Return the profile/report name."""
        return self.data.get('selected')

    @selected.setter
    def selected(self, selected):
        """Return the profile/report name."""
        self.data['selected'] = selected

    @property
    def validation_success(self):
        """Return the profile/report validation_success."""
        return self.data.get('validation_success')

    @validation_success.setter
    def validation_success(self, validation_success):
        """Set the profile/report validation_success."""
        self.data['validation_success'] = validation_success

    def __str__(self):
        return json.dumps(self.data, indent=2, sort_keys=True)


class Reports(object):
    """Run Report"""

    def __init__(self):
        """Initialize class properties."""
        self.report = {
            'profiles': [],
            'results': {
                'executions': {
                    'fail': 0,
                    'pass': 0
                },
                'total': 0,
                'validations': {
                    'fail': 0,
                    'pass': 0
                },
            },
            'settings': {
                'provided_group': 'qa-build',
                'provided_profile': 'default',
                'selected_profiles': []
            }
        }
        self.profiles = {}
        self.selected_profile = None

    def add_profile(self, profile, selected):
        """Add profile to report."""
        report = Report(profile)
        report.selected = selected
        self.report['settings']['selected_profiles'].append(report.name)
        self.profiles.setdefault(report.name, report)
        return report

    def exit_code(self, code):
        """Set the exit code on the selected profile."""
        self.selected_profile.data['exit_code'] = code

    def increment_total(self):
        """Return run total value."""
        self.report['results']['total'] += 1

    def profile(self, name):
        """Return a specific profile."""
        self.selected_profile = self.profiles.get(name)
        return self.profiles.get(name)

    def profile_execution(self, status):
        """Return run total value."""
        self.selected_profile.data['execution_success'] = status
        if status:
            self.report['results']['executions']['pass'] += 1
        else:
            self.report['results']['executions']['fail'] += 1

    def profile_validation(self, status):
        """Return run total value."""
        self.selected_profile.data['validation_success'] = status
        if status:
            self.report['results']['validations']['pass'] += 1
        else:
            self.report['results']['validations']['fail'] += 1

    def __str__(self):
        return json.dumps(self.profiles, indent=2, sort_keys=True)


if __name__ == '__main__':
    try:
        tcr = TcRun(args)
        profile_count = 0
        for p in tcr.profiles:
            separator = '=' * 20
            tcr.log.info('{} {} {}'.format(separator, p.get('profile_name'), separator))
            tcr.profile = p

            if args.gen_launcher:
                tcr.gen_launcher()
                continue
            # print(json.dumps(p, indent=4))
            tcr.clear()
            tcr.stage()
            tcr.run()

            if profile_count > 0:
                sleep = self.profile.get('sleep', self.config.get('sleep', self.sleep))
                print('Sleep: {}{}{} seconds'.format(c.Style.BRIGHT, c.Fore.YELLOW, sleep))
                time.sleep(sleep)
            profile_count =+ 1
        tcr.log.info('Exit Code: {}'.format(tcr.exit_code))
        sys.exit(tcr.exit_code)
    except Exception as e:
        # TODO: Update this, possibly raise
        print('{}{}{}'.format(c.Style.BRIGHT, c.Fore.RED, traceback.format_exc()))
        sys.exit(1)
